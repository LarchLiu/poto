import { dirname, isAbsolute, relative, resolve } from 'path'
import { promises as fs } from 'fs'
import { slash, throttle, toArray } from '@antfu/utils'
import type { Import } from 'unimport'
import { createUnimport, scanDirExports } from 'unimport'
import { camelCaseWithoutAt } from '@poto/utils'
import type { ImportExtended, Options } from '../types'

const defaultExportPath = 'src/poto-auto-imports.ts'

export function createContext(options: Options = {}, root = process.cwd()) {
  const imports = flattenImports(options.imports, options.overriding)

  const dirs = options.dirs?.map(dir => resolve(root, dir))

  const unimport = createUnimport({
    imports: imports as Import[],
  })

  const exportPath = resolve(root, options.exportPath ?? defaultExportPath)

  function resolvePath(file: string, i: Import) {
    const dir = dirname(file)
    if (i.from.startsWith('.') || isAbsolute(i.from)) {
      const related = slash(relative(dir, i.from).replace(/\.ts$/, ''))
      return !related.startsWith('.')
        ? `./${related}`
        : related
    }
    return i.from
  }

  function generateExport() {
    let str = '// Generated by \'@poto/auto-import\'\nimport type { BlockInfo } from \'@poto/types\'\n'
    unimport.getImports().forEach((i) => {
      const from = resolvePath(exportPath, i)
      str += `import ${i.as} from '${from}'\n`
    })
    str += '\n'

    let importStr = ''
    unimport.getImports().sort((a, b) => (a.as ?? a.name).localeCompare((b.as ?? b.name))).forEach((i) => {
      const name = i.as ?? i.name
      importStr += `  ${name}: { blockView: ${name}.blockView, settingsView: ${name}.settingsView, config: ${name}.config },\n`
    })

    const importObj = `export const BlockPlugins: BlockInfo = {\n${importStr}}\n`
    return str + importObj
  }

  const writeConfigFilesThrottled = throttle(500, false, writeConfigFiles)

  let lastImport: string | undefined

  function writeConfigFiles() {
    const promises: any[] = []
    if (exportPath) {
      const content = generateExport()
      if (content !== lastImport) {
        lastImport = content
        promises.push(fs.writeFile(exportPath, content, 'utf-8'))
      }
    }
    return Promise.all(promises)
  }

  async function scanDirs() {
    if (dirs?.length) {
      await unimport.modifyDynamicImports(async (imports) => {
        const exports = (await scanDirExports(dirs, { fileFilter: options.fileFilter ? options.fileFilter : () => true }) as ImportExtended[]).filter(i => i.name === 'default')
        exports.forEach(i => i.__source = 'dir')
        return [
          ...imports.filter((i: ImportExtended) => i.__source !== 'dir'),
          ...exports,
        ] as Import[]
      })
    }
    writeConfigFilesThrottled()
  }

  return {
    root,
    dirs,
    generateExport,
    scanDirs,
    writeConfigFiles,
    writeConfigFilesThrottled,
  }
}

export function flattenImports(map: Options['imports'], overriding = false): Import[] {
  const flat: Record<string, Import> = {}
  toArray(map).forEach((definition) => {
    const as = camelCaseWithoutAt(definition)
    const meta = {
      name: definition,
      as,
      from: definition,
    } as Import

    if (flat[as] && !overriding)
      throw new Error(`[poto-auto-import] identifier ${as} already defined with ${flat[as].from}`)

    flat[as] = meta
  })

  return Object.values(flat)
}
